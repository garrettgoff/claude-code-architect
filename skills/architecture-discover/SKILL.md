---
name: architecture-discover
description: Reverse-engineer architecture documentation from existing codebases by analyzing code structure, imports, exports, and relationships. Use when adding architecture docs to mature projects.
---

# Architecture Discovery Skill

## Purpose
Analyze an existing codebase to infer architectural structure and generate ARCHITECTURE.md files based on actual code organization.

## When to Use
- Adding architecture documentation to an existing project
- Codebase has evolved without formal architecture docs
- Need to understand legacy code structure
- Auditing architecture vs implementation alignment

## Discovery Process

### Phase 1: Repository Analysis

**1. Scan Codebase Structure**
- Identify programming language(s)
- Find package/module boundaries (package.json, go.mod, __init__.py, etc.)
- Map directory hierarchy
- Identify configuration files, build files, test directories

**2. Build Dependency Graph**
- Parse import/require statements
- Track which files/modules depend on which
- Identify entry points (main, index, CLI)
- Find external dependencies vs internal modules

**3. Identify Component Boundaries**
Look for natural boundaries:
- Separate directories with cohesive purpose
- Modules with clear import/export patterns
- Subsystems with minimal cross-talk
- Domain-driven directory structure (auth/, api/, db/, ui/)

### Phase 2: Component Analysis

For each identified component:

**1. Infer Purpose**
- Read package.json description, docstrings, README files
- Analyze file names and directory names
- Look at main exported functions/classes
- Check comments at top of key files

**2. Extract External Interfaces (Provides)**
- Public exports (export, module.exports, public classes)
- REST/GraphQL endpoints
- CLI commands
- Event emitters
- Shared types/interfaces

**3. Identify Dependencies (Requires)**
- Imports from other internal components
- External library dependencies
- Environment variables
- Configuration requirements
- Database/API connections

**4. Map Internal Structure**
- Subdirectories as potential subcomponents
- Major classes/files as internal elements
- Data flow between internal pieces
- Shared utilities vs core logic

### Phase 3: Hierarchy Construction

**1. Build Component Tree**
- Start with root (entire repo)
- Identify top-level components
- Recursively analyze subcomponents
- Determine single-file vs multi-file components

**2. Validate Boundaries**
- Check for circular dependencies (bad!)
- Look for god modules (too many responsibilities)
- Identify coupling hotspots
- Find orphaned code

**3. Classify Stability**
- Analyze git history (frequently changed vs stable)
- Count dependencies (highly depended upon = core)
- Identify experimental vs production code

### Phase 4: Documentation Generation

**1. Generate ARCHITECTURE.md Files**
For each component:
```markdown
---
managed-by: arch-plugin
schema-version: 1.0.0
doc-version: 1.0.0
last-updated: [DATE]
stability: [inferred | stable | experimental]
---

# [Component Name]

## Purpose
[Inferred from code analysis, flagged for human review]

## External Interfaces

### Provides (Ports)
[Extracted from exports/public APIs]
- `function_name(params) -> return`: [from JSDoc/docstring or code]

### Requires (Ports)
[Extracted from imports]
- `OtherComponent.function()`: [usage context]
- External: library-name v1.2.3

## Internal Architecture

### Subcomponents
[Based on subdirectories and major modules]
- **SubcomponentName** (at `./path/`): [Inferred purpose]

### Internal Interfaces (Connections)
[Based on internal imports and data flow]
- SubA → SubB: `interface_name()` - [inferred purpose]

## Notes
**Generated by architecture-discover**
- Confidence: [HIGH | MEDIUM | LOW]
- Needs review: [List of uncertain aspects]
- Detected issues: [Circular deps, coupling, etc.]

---
*Parent: [parent component]*
```

**2. Flag Uncertainties**
Mark sections that need human review:
- Unclear purpose (generic names, no docs)
- Complex dependency patterns
- Potential architectural violations
- Missing documentation in code

**3. Generate Discovery Report**
```markdown
# Architecture Discovery Report

## Summary
- Total components discovered: 15
- Component hierarchy depth: 3 levels
- Total dependencies analyzed: 142
- External dependencies: 23

## High Confidence Components (8)
- auth/ - Clear authentication module
- api/ - REST API endpoints
- db/ - Database access layer

## Medium Confidence Components (5)
- utils/ - Mixed utility functions (recommend splitting)
- services/ - Various services (boundary unclear)

## Low Confidence / Needs Review (2)
- legacy/ - Purpose unclear, many deps
- shared/ - God module, used everywhere

## Detected Issues
### Circular Dependencies
- ComponentA ↔ ComponentB (via utils.ts)

### Architectural Smells
- utils/ imported by 12 components (god module)
- auth/ has 8 external dependencies (high coupling)

### Orphaned Code
- old-api/ - not imported anywhere
- scripts/temp/ - unclear purpose

## Recommendations
1. Split utils/ into focused modules
2. Resolve ComponentA/B circular dependency
3. Review auth/ dependency count
4. Clean up or document old-api/
5. Document 5 components flagged as low-confidence

## Next Steps
1. Review generated ARCHITECTURE.md files
2. Fill in uncertain Purpose sections
3. Verify inferred interfaces match intent
4. Address detected architectural issues
```

## Language-Specific Strategies

### JavaScript/TypeScript
- Parse `import`/`export` statements
- Read JSDoc comments
- Check package.json exports field
- Analyze TypeScript types for interfaces

### Python
- Parse `import`/`from` statements
- Read module docstrings
- Check `__init__.py` for public API
- Analyze `__all__` exports

### Go
- Parse `import` statements
- Check package comments
- Identify exported (capitalized) functions
- Read go.mod for module boundaries

### Java
- Parse `import` statements
- Read JavaDoc
- Identify public classes/methods
- Check package structure

### Rust
- Parse `use` statements
- Read module docs (`///`, `//!`)
- Check `pub` visibility
- Analyze Cargo.toml

## Output

**Generated Files:**
- ARCHITECTURE.md at each component level
- Discovery report summarizing findings
- List of issues/uncertainties for review

**Interactive Review:**
- Present findings to user
- Ask for clarification on uncertain areas
- Let user approve/reject inferred boundaries
- Allow manual adjustments before finalizing

## Quality Heuristics

**High Confidence Indicators:**
- Clear directory names (auth, api, db)
- Good code documentation
- Clean import patterns
- Obvious single responsibility

**Low Confidence Indicators:**
- Generic names (utils, helpers, common)
- No documentation
- Complex import graphs
- Mixed responsibilities

**Red Flags:**
- Circular dependencies
- God modules (imported everywhere)
- Orphaned code
- Inconsistent patterns

## Validation

After generating docs:
1. Check all parent references are valid
2. Verify all mentioned subcomponents exist
3. Ensure interface consistency (provide/require match)
4. Flag any detected architectural violations

## Usage Notes

- This is a **starting point**, not perfect documentation
- Always review and refine generated docs
- Mark uncertain sections for human attention
- Use git history to understand evolution
- Consider interviewing developers for context
- Iterate: generate, review, refine, repeat

## Limitations

**Cannot infer:**
- Architectural intent (only structure)
- Business context
- Historical decisions
- Future plans
- Non-code dependencies (services, infrastructure)

**May struggle with:**
- Dynamic imports/reflection
- Plugin architectures
- Metaprogramming
- Heavily abstracted code
- Microservices (need deployment info)
